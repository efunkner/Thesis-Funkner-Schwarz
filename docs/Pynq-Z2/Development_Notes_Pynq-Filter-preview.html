<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.7.23">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


    <title>development_notes_pynq-filter</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "../index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="../site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-58d60837e5c3cc41aed2b21062153a0f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
     
      </head>

  <body class="quarto-notebook quarto-light">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Zurück zum Artikel</a>
      <h6><i class="bi bi-journal-code"></i> Notiezen und Information zu dem Entwiklungsstatus</h6>

            <a href="../Pynq-Z2/Development_Notes_Pynq-Filter.md" class="btn btn-primary quarto-download-embed" download="Development_Notes_Pynq-Filter.md">Notizbuch herunterladen</a>
          </div>

     <div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#notiezen-und-information-zu-dem-entwiklungsstatus" id="toc-notiezen-und-information-zu-dem-entwiklungsstatus" class="nav-link active" data-scroll-target="#notiezen-und-information-zu-dem-entwiklungsstatus">Notiezen und Information zu dem Entwiklungsstatus</a></li>
  <li><a href="#stand-09.06.2025" id="toc-stand-09.06.2025" class="nav-link" data-scroll-target="#stand-09.06.2025">Stand : 09.06.2025</a>
  <ul class="collapse">
  <li><a href="#filter" id="toc-filter" class="nav-link" data-scroll-target="#filter">Filter:</a></li>
  <li><a href="#jupiternotebooks" id="toc-jupiternotebooks" class="nav-link" data-scroll-target="#jupiternotebooks">JupiterNotebooks:</a></li>
  <li><a href="#bekannte-probleme" id="toc-bekannte-probleme" class="nav-link" data-scroll-target="#bekannte-probleme">Bekannte Probleme:</a></li>
  <li><a href="#echtzeitfiltrierung" id="toc-echtzeitfiltrierung" class="nav-link" data-scroll-target="#echtzeitfiltrierung">Echtzeitfiltrierung</a>
  <ul class="collapse">
  <li><a href="#probleme-mit-echtzeit" id="toc-probleme-mit-echtzeit" class="nav-link" data-scroll-target="#probleme-mit-echtzeit">Probleme mit Echtzeit</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#stand-11.06.2025" id="toc-stand-11.06.2025" class="nav-link" data-scroll-target="#stand-11.06.2025">Stand : 11.06.2025</a>
  <ul class="collapse">
  <li><a href="#filter-1" id="toc-filter-1" class="nav-link" data-scroll-target="#filter-1">Filter:</a></li>
  <li><a href="#vivado-design" id="toc-vivado-design" class="nav-link" data-scroll-target="#vivado-design">Vivado Design:</a></li>
  <li><a href="#jupiternotebooks-1" id="toc-jupiternotebooks-1" class="nav-link" data-scroll-target="#jupiternotebooks-1">JupiterNotebooks:</a></li>
  </ul></li>
  <li><a href="#stand-12.06.2025" id="toc-stand-12.06.2025" class="nav-link" data-scroll-target="#stand-12.06.2025">Stand : 12.06.2025</a>
  <ul class="collapse">
  <li><a href="#jupiternotebooks-2" id="toc-jupiternotebooks-2" class="nav-link" data-scroll-target="#jupiternotebooks-2">JupiterNotebooks:</a></li>
  <li><a href="#bemerkungen" id="toc-bemerkungen" class="nav-link" data-scroll-target="#bemerkungen">Bemerkungen:</a></li>
  </ul></li>
  <li><a href="#stand-13.06.2025" id="toc-stand-13.06.2025" class="nav-link" data-scroll-target="#stand-13.06.2025">Stand : 13.06.2025</a>
  <ul class="collapse">
  <li><a href="#jupiternotebooks-3" id="toc-jupiternotebooks-3" class="nav-link" data-scroll-target="#jupiternotebooks-3">JupiterNotebooks:</a></li>
  <li><a href="#bemerkungen-1" id="toc-bemerkungen-1" class="nav-link" data-scroll-target="#bemerkungen-1">Bemerkungen:</a></li>
  </ul></li>
  <li><a href="#stand-17.06.2025" id="toc-stand-17.06.2025" class="nav-link" data-scroll-target="#stand-17.06.2025">Stand : 17.06.2025</a>
  <ul class="collapse">
  <li><a href="#echtzeitfiltrierung-2" id="toc-echtzeitfiltrierung-2" class="nav-link" data-scroll-target="#echtzeitfiltrierung-2">Echtzeitfiltrierung 2</a></li>
  <li><a href="#noch-offene-punkte" id="toc-noch-offene-punkte" class="nav-link" data-scroll-target="#noch-offene-punkte">Noch offene Punkte:</a></li>
  <li><a href="#bereits-erledigt" id="toc-bereits-erledigt" class="nav-link" data-scroll-target="#bereits-erledigt">Bereits erledigt:</a></li>
  <li><a href="#zusatz" id="toc-zusatz" class="nav-link" data-scroll-target="#zusatz">Zusatz:</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      <section id="notiezen-und-information-zu-dem-entwiklungsstatus" class="level1">
<h1>Notiezen und Information zu dem Entwiklungsstatus</h1>
<p>Dies sind die Notizen zum aktuellen Stand der Umsetzung von IIR-Biquad-Filtern auf dem PYNQ-Z2. <br> Die Jupyter-Notebooks befinden sich im Verzeichnis <em>jupyter</em>. <br> <strong>Wichtig</strong>: Es kann sein, dass die Notebooks nicht vollständig in git angezeigt werden! Beim Öffnen mit einem externen Programm (z.B. VSCode) wird das gesammte Notebook angezeigt.</p>
</section>
<section id="stand-09.06.2025" class="level1">
<h1>Stand : 09.06.2025</h1>
<section id="filter" class="level3">
<h3 class="anchored" data-anchor-id="filter">Filter:</h3>
<p>Der derzeit implementierte Filter dient als funktionsfähiger Platzhalter. Es handelt sich um ein Butterworth-Hochpassfilter mit einer Grenzfrequenz von 1 kHz und einer Abtastrate von 48 kHz, abgestimmt auf den im PYNQ-Z2 integrierten Audiocodec <a href="https://www.analog.com/en/products/adau1761.html">ADAU1761</a>. <br> Der Filter wurde mithilfe des HDL-Coders aus einem MATLAB/Simulink-Modell generiert und als IP-Core umgesetzt, um eine nahtlose Integration in Vivado zu ermöglichen. <br></p>
</section>
<section id="jupiternotebooks" class="level3">
<h3 class="anchored" data-anchor-id="jupiternotebooks">JupiterNotebooks:</h3>
<section id="filter_transmissiontestmatlab_filter_test_transmissiontest_v2v5" class="level4">
<h4 class="anchored" data-anchor-id="filter_transmissiontestmatlab_filter_test_transmissiontest_v2v5">Filter_TransmissionTest/Matlab_Filter_Test_TransmissionTest_v2|v5</h4>
<p>Diese beiden Notebooks dokumentieren die ersten erfolgreichen Versuche, zunächst simulierte Signale und anschließend beide Kanäle einer .wav-Datei zu filtern. Die Signale wurden dabei als np.array per DMA (Direct Memory Access) an den Filter übertragen, verarbeitet und anschließend wieder ausgegeben. <br> Vor der Übertragung werden die Arrays in Pakete von jeweils 262144 Elementen aufgeteilt. Diese Paketgröße entspricht der Größe des Output-Buffers der Filter-IP. Durch die automatische Paketaufteilung lassen sich auch Daten beliebiger Länge problemlos übertragen. <br> Der Ein- und Ausgangsbuffer des DMA wurde vorsorglich auf den Maximalwert von 67108864 gesetzt.</p>
<p>Beim Erstellen der DMA-Buffer in Python werden diese mit undefinierten Werten befüllt, die intern als NaN (Not a Number) oder nicht-initialisierte Daten erscheinen können. Beim Anzeigen per print() wirken sie zwar wie Nullen, enthalten aber tatsächlich keine gültigen, interpretierten Werte.<br> Wenn der Buffer größer ist als die tatsächlich zu übertragenden Daten und nicht vollständig mit gültigen Werten überschrieben wird, bleiben diese ungültigen Inhalte im Speicher. Werden diese vom DMA übertragen, kann dies zu internen Fehlerzuständen führen, wodurch der DMA blockiert wird und weitere Übertragungen nicht mehr möglich sind.<br> Um dennoch mit großen DMA-Frames arbeiten zu können, müssen die Buffer vollständig mit gültigen Daten gefüllt werden.<br></p>
<p><strong>Lösung:</strong> Vor der Übertragung wird der gesamte Buffer initial mit Nullen befüllt (Padding). Anschließend werden die tatsächlichen Nutzdaten am Anfang des Buffers überschrieben. Dadurch enthält der komplette Buffer gültige, wohldefinierte Werte, was dem DMA eine fehlerfreie Übertragung ermöglicht.</p>
</section>
<section id="audio_filter_test_v2codec_test_v6" class="level4">
<h4 class="anchored" data-anchor-id="audio_filter_test_v2codec_test_v6">Audio_Filter_Test_v2/Codec_Test_v6</h4>
<p>Dieses Notebook ist eine erweiterung der Vorherigen. Das hier verwendete Design basiert vollständig auf dem des <em>base.bit</em> welches vom <a href="https://github.com/Xilinx/PYNQ/tree/master">Pynq Github Repo</a> stammt und auch in den Beispielen aus der <a href="https://pynq.readthedocs.io/en/v2.6.1/pynq_libraries/audio.html">Docs » PYNQ Libraries » Audio</a> angewand wird. Dabei wurde praktisch nur der für den <a href="https://www.analog.com/en/products/adau1761.html">ADAU1761 Audio-Codec</a> erstellte Teil des Designs übernommen.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Design/audio_test_ref_design.pdf" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Blockdiagramm_Referenz"><embed src="Design/audio_test_ref_design.pdf" class="img-fluid"></a></p>
<figcaption>Blockdiagramm_Referenz</figcaption>
</figure>
</div>
<p>Hinzugefügt wurde der im Vorheriegen Notebook erstellte Filter und DMA, um vom Board aufgenommende Audio direkt Filtern zu können.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Design/audio_test_3_ref.pdf" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Blockdiagramm_Referenz"><embed src="Design/audio_test_3_ref.pdf" class="img-fluid"></a></p>
<figcaption>Blockdiagramm_Referenz</figcaption>
</figure>
</div>
<p>Die angewanden Funktionen stammen aus dem <a href="https://pynq.readthedocs.io/en/v2.6.1/pynq_package/pynq.lib/pynq.lib.audio.html#pynq-lib-audio">pynq.lib.audio Module</a>.</p>
</section>
</section>
<section id="bekannte-probleme" class="level3">
<h3 class="anchored" data-anchor-id="bekannte-probleme">Bekannte Probleme:</h3>
<ul>
<li>Die Auswahl des Audio-Eingangs ist nicht immer zuverlässig und muss teilweise mehrfach durchgeführt werden.</li>
<li>Der Python-Kernel stürzt bei größeren Datensätzen regelmäßig ab, wodurch die Verbindung zum Board verloren geht. → Die Abstürze treten scheinbar zufällig auf und folgen keinem erkennbaren Muster. Ein Hardreset ist anschließend erforderlich.</li>
<li>Beim Laden eines neuen Overlays wird dieses nicht immer korrekt übernommen: das vorherige Overlay wird manchmal nicht überschrieben. → Auch hier ist ein Hardreset notwendig.</li>
<li>Aufnahmen bei höherer Lautstärke können Störgeräusche oder Rückkopplungen verursachen.</li>
<li>Aufgenommene Audiodateien sind im Vergleich zur Ausgabe über das Board deutlich leiser.</li>
<li>Ausgabe rauscht, potenzielle Folge vom Filtertyp oder der Umrechnung vor dem Filtern</li>
</ul>
</section>
<section id="echtzeitfiltrierung" class="level2">
<h2 class="anchored" data-anchor-id="echtzeitfiltrierung">Echtzeitfiltrierung</h2>
<section id="probleme-mit-echtzeit" class="level3">
<h3 class="anchored" data-anchor-id="probleme-mit-echtzeit">Probleme mit Echtzeit</h3>
<section id="ausgangslage" class="level4">
<h4 class="anchored" data-anchor-id="ausgangslage">Ausgangslage</h4>
<p>Um das I2S Signal Echtzeitfiltern zu können, muss der Filter zwischen dieses Signal gesetzt werden. In Vivado gibt es I2S Receiver/Transmitter Ip-Cores welche ein I2S Signal annehmen können und als AXI4-Stream ausgeben können und andersrum mit dem Transmitter. Der Filter kann als AXI4-Stream fähiger IP-Core in Matlab erstellt werden und wurde so auch bisher verwendet. Daher könnte der Filter über die I2S Receiver/Transmitter Blöcke an den I2S-Stream angebunden werden.</p>
</section>
<section id="problem-mit-i2s-receivertransmitter" class="level4">
<h4 class="anchored" data-anchor-id="problem-mit-i2s-receivertransmitter">Problem mit I2S Receiver/Transmitter</h4>
<p>Der Audio_Codec_Contrtoller Block ist ein vorgefertigter IP-Core aus dem <a href="https://github.com/Xilinx/PYNQ/tree/master">Pynq Github Repo</a> welcher bei der I2S Übertragung als Master funktioniert und damit <em>bclk</em>, <em>lrclk</em> und <em>codec_addr</em> vorgibt.<br> Das Problem mit den I2S Receiver/Transmitter Ip-Cores ist, dass diese in dieser Konfiguration als <em>Slave</em> arbeiten müssten. Die Funktion wird aber nicht unterstützt. Bedeutet das die IP-Cores nur als <em>Master</em> Arbeiten können. <a href="https://docs.amd.com/r/en-US/pg308-i2s/Navigating-Content-by-Design-Process">I2S Transmitter and I2S Receiver LogiCORE IP Product Guide</a> <br> Also muss entweder eine andere IP mit Unterstützung als <em>Slave</em> her oder dies muss eigens entwickelt werden. <br> Alternativ könnte auch der Filter IP-Core so umgestaltet werden, dass dieser ein Eingangs I2S-Streams akzeptiert. Dadurch würde sie aber die voraussichtlich die Unterstützung von AXI4-Stream verlieren, wodurch diese auch nicht länger für Digitale Audioquellen wie <em>.wav</em> verwendet werden könnten, weshalb derselbe Filter zweimal erstellt werden mussen. <br> Es gibt eine Möglichkeit die I2S Receiver/Transmitter von <em>Master</em> in <em>Slave</em> umzuändern laut dieser Quelle: <a href="https://www.hackster.io/adam-taylor/audio-processing-with-the-snickerdoodle-727c40">Audio Processing with the Snickerdoodle</a>. Anderes Board aber änhliche SoC. Leider gelang es mir bisher nicht diese erfolgreich anzuwenden.</p>
<section id="takt-daten-desynchronisation-bei-slave-slave-betrieb" class="level5">
<h5 class="anchored" data-anchor-id="takt-daten-desynchronisation-bei-slave-slave-betrieb">Takt-Daten-Desynchronisation bei Slave-Slave-Betrieb</h5>
<p>Wenn Receiver und Transmitter beide Slave sind, verwenden sie bclk und lrclk vom codec_ctrl_0 <br> <strong>Das Problem ist:</strong> Der i2s_receiver_0 wandelt das serielle Signal sdata_i in AXI-Wörter (z.B. 24 Bit). Diese passieren eine Verarbeitung, z.B. dein Filter. Danach gibt i2s_transmitter_0 sie zurück, synchron zu <strong>alten</strong> Taktsignalen (bclk, lrclk) <br> - Die Daten sind nun potenziell verzögert, und stimmen nicht mehr zur aktuellen lrclk/bclk-Phase.<br></p>
</section>
<section id="master-transmitter-bricht-den-systemtakt" class="level5">
<h5 class="anchored" data-anchor-id="master-transmitter-bricht-den-systemtakt">Master-Transmitter bricht den Systemtakt</h5>
<p>Wenn ich den Transmitter als Master einstelle, erzeugt er eigene bclk und lrclk. Damit erzeugt er ein I²S-Signal mit eigenem Timing, und der audio_codec_ctrl_0 (und damit der Codec) müssten nun als Slave arbeiten. <br> - <em>Der Controller ist als Takt-Master hart konfiguriert</em>, also: <strong>Kann bclk/lrclk nicht extern empfangen, sondern erzeugt sie.</strong></p>
</section>
<section id="gleichzeitige-audio-wiedergabe-und--ausgabe" class="level5">
<h5 class="anchored" data-anchor-id="gleichzeitige-audio-wiedergabe-und--ausgabe">Gleichzeitige Audio-Wiedergabe und -Ausgabe</h5>
<p>In dem <a href="https://www.mouser.com/pdfDocs/pynqz2_user_manual_v1_0.pdf">Pynq-Z2</a> ist ein <a href="https://www.analog.com/en/products/adau1761.html">ADAU1761 Audio-Codec</a> verbaut. In dem Datenblatt wird nicht expleziet erwähnt ob eine gelcihzeitige Aufnahme und Wiedergabe möglich ist, technisch währe es aber. Wenn die Funktionen aus dem <a href="https://pynq.readthedocs.io/en/v2.6.1/pynq_package/pynq.lib/pynq.lib.audio.html#pynq-lib-audio">pynq.lib.audio Module</a> verwendet werden wird, ist es nicht möglich. Sobald eine Aufnahme <em>.record(Time)</em> gestart wird, wird die Ausgabe <em>.play()</em> blockiert bis die Aufnahme vollendet ist. <br> Mit dem Base-Design, sowie auch diesem hier, ist so direckt die gleichzeitige aufnahme und wiedergabe nicht möglich.</p>
</section>
</section>
<section id="alternative-design-möglichkeiten" class="level4">
<h4 class="anchored" data-anchor-id="alternative-design-möglichkeiten">Alternative Design Möglichkeiten</h4>
<p>Es gibt andere Projekte welche es ermöglichen gelichzeitig Audio Aufzunehmen und Widerzugeben. Inwieweit diese hier verwendet werden können muss noch weiter unteruscht werden. <br> Hier eine Liste von Projekten die bereits ausprobiert wurden: <br></p>
<p><a href="https://github.com/wady101/PYNQ_Z2-Audio/tree/master">Pynq_Z2-Audio</a> <br> <a href="https://www.hackster.io/adam-taylor/audio-processing-with-the-snickerdoodle-727c40">Audio Processing with the Snickerdoodle</a><br> <a href="https://github.com/reed-foster/pynq-audio/tree/master">pynq-audio</a><br> <a href="https://github.com/tmaringer/Pynq-Z2-Audio-Video-Pipelines">Pynq-Z2-Audio-Video-Pipelines</a> <br></p>
</section>
</section>
</section>
</section>
<section id="stand-11.06.2025" class="level1">
<h1>Stand : 11.06.2025</h1>
<section id="filter-1" class="level3">
<h3 class="anchored" data-anchor-id="filter-1">Filter:</h3>
<p>Zwei neue Filter wurden entworfen und jeweils in Kombination mit einer eigenen AXI-DMA implementiert. Die Filterdesigns basieren auf dem MATLAB Filter Designer, wobei die entsprechenden Koeffizienten ins Workspace exportiert wurden: - Hochpass: Butterworth, 4. Ordnung, FC: 2500 Hz - Tiefpass: Butterworth, 4. Ordnung, FC: 1000 Hz</p>
<p>Das Simulink-Modell <em>(biquad_Filter_v7_IP)</em> wurde entsprechend angepasst: Die Gain-Faktoren <em>(g)</em> werden nun direkt in die Numerator-Koeffizienten integriert. Da der MATLAB Filter Designer für jeden Biquad-Block einen eigenen Gain-Wert erzeugt, liegen nun entsprechend mehr Gain-Faktoren vor.</p>
<p>Diese Änderung wurde vorgenommen, da beim Tiefpassfilter die nachträgliche Anwendung des Gains dazu führte, dass die Werte zu klein wurden. Aufgrund des 32_16 Fixed-Point-Formats im Simulink-Modell kam es dadurch zu Rundungsfehlern bzw. zum Wegfallen relevanter Werte. Durch das Vorab-Einrechnen der Gains in die Numerator-Koeffizienten wird dieses Problem vermieden, ohne dass sich das Filterverhalten ändert.</p>
</section>
<section id="vivado-design" class="level3">
<h3 class="anchored" data-anchor-id="vivado-design">Vivado Design:</h3>
<p>Im Zuge der neuen Filter wurde auch das Design in Vivado angepasst. Als Grundlage diente das überarbeitete Referenzdesign v2, das eine angepasste Takterzeugung für den Audio-Codec beinhaltet. Jeder der beiden Filter erhält eine eigene AXI-DMA-Schnittstelle, wobei beide Schnittstellen identisch konfiguriert wurden. <br></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="Design/audio_duo_Filter_v1_bunt.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="audio_duo_Filter_v1"><img src="Design/audio_duo_Filter_v1_bunt.png" class="img-fluid figure-img" alt="audio_duo_Filter_v1"></a></p>
<figcaption>audio_duo_Filter_v1</figcaption>
</figure>
</div>
<p>Beim ersten Versuch der Bitstream-Generierung trat ein Synthese-Fehler auf. Nach erneutem Ausführen des Generierungsprozesses konnte der Bitstream jedoch erfolgreich erstellt werden. Ein solches Verhalten wurde bereits in der Vergangenheit bei größeren Designs beobachtet und hatte bislang keine Auswirkungen auf die Funktionalität des erzeugten Bitstreams. <br></p>
<p>Die Timings im Design wurden erfolgreiuch eingehalten. <img src="Design/audio_duo_Filter_v1_Vivado1.png" class="img-fluid" alt="audio_duo_Filter_v1:Timing"></p>
</section>
<section id="jupiternotebooks-1" class="level3">
<h3 class="anchored" data-anchor-id="jupiternotebooks-1">JupiterNotebooks:</h3>
<section id="audio_duo_filter_v1" class="level4">
<h4 class="anchored" data-anchor-id="audio_duo_filter_v1">Audio_duo_Filter_v1</h4>
<p>Das Notebook basiert auf einer früheren Version und unterscheidet sich hauptsächlich in der Anzahl der implementierten Filter. Es wurde dahingehend erweitert, dass einer der beiden Filter zur Laufzeit ausgewählt werden kann. Das Notebook diente zur Überprüfung der Funktionalität des Designs – der Test verlief erfolgreich, die korrekte Funktion konnte bestätigt werden.</p>
</section>
</section>
</section>
<section id="stand-12.06.2025" class="level1">
<h1>Stand : 12.06.2025</h1>
<section id="jupiternotebooks-2" class="level3">
<h3 class="anchored" data-anchor-id="jupiternotebooks-2">JupiterNotebooks:</h3>
<section id="audio_duo_filter_v2" class="level4">
<h4 class="anchored" data-anchor-id="audio_duo_filter_v2">Audio_duo_Filter_v2</h4>
<p>Aktualisierte Version von <em>Audio_duo_Filter_v1</em>. <br> Erweitert wurde das Projekt um eine Dokumentation der verwendeten Funktionen, sowohl der Pynq-eigenen als auch der selbst entwickelten. <br> Zudem wurde die Filterverarbeitung von 16-Bit auf vollständige 24-Bit erweitert. <br> Zur Überprüfung wurden die Phasenantworten des Hochpass- (HP) und Tiefpassfilters (TP) analysiert.</p>
</section>
<section id="audio_duo_filter_v3" class="level4">
<h4 class="anchored" data-anchor-id="audio_duo_filter_v3">Audio_duo_Filter_v3</h4>
<p>Die Funktionen wurden in eine separate Python-Datei (<em>my_Overlay.py</em>) ausgelagert, um die Übersichtlichkeit des Notebooks zu verbessern. Zusätzlich wurde eine neue Funktion integriert, die den gesamten Filterprozess, einschließlich Übertragung, Einlesen, Speichern sowie Filterauswahl, in einem einzigen Aufruf zusammenfasst. <br> Alle bisherigen Funktionen bleiben unverändert und funktionieren weiterhin wie zuvor.</p>
</section>
</section>
<section id="bemerkungen" class="level3">
<h3 class="anchored" data-anchor-id="bemerkungen">Bemerkungen:</h3>
<ul>
<li>Die Audioaufnahme über das Board ist nicht immer fehlerfrei.</li>
<li>In seltenen Fällen tritt bei der Filterung ein Problem auf, bei dem starke Frequenzspitzen im Bereich von 10–20 kHz entstehen. Die Ursache dafür ist bislang unbekannt: beobachtet wurde dieses Verhalten bisher nur einmal beim Tiefpassfilter.</li>
<li>Die Filterwirkung des Hochpassfilters bei einer Grenzfrequenz von 2500 Hz ist unbefriedigend, es werden zu viele Frequenzanteile abgeschnitten, was zu einem unsauberen Klang führen kann.</li>
<li>Beim Einsatz von Python-Bibliotheken wie matplotlib kommt es bei längeren Aufnahmen zu Instabilitäten im Python-Kernel. Eine Auslagerung der Auswertungen in ein separates Notebook ist daher geplant.</li>
</ul>
</section>
</section>
<section id="stand-13.06.2025" class="level1">
<h1>Stand : 13.06.2025</h1>
<section id="jupiternotebooks-3" class="level3">
<h3 class="anchored" data-anchor-id="jupiternotebooks-3">JupiterNotebooks:</h3>
<section id="lerndemo_v1_audio" class="level4">
<h4 class="anchored" data-anchor-id="lerndemo_v1_audio">Lerndemo_v1_Audio</h4>
<p>Neues Notebook sowie eine aktualisierte Version von <em>my_Overlay_v2.py</em> mit erweiterten Funktionen für grafische Darstellung der Ergebnisse. - Enthält eine Funktion zur Darstellung eines einfachen Frequenzspektrums beider Audiokanäle auf Basis einer FFT. - Zusätzlich wurde eine Funktion integriert, die die Audiodaten im Zeitbereich visualisiert.</p>
</section>
</section>
<section id="bemerkungen-1" class="level3">
<h3 class="anchored" data-anchor-id="bemerkungen-1">Bemerkungen:</h3>
<ul>
<li>Die maximale Aufnahmezeit beträgt 60 Sekunden und ist durch den Audio-Codec-Treiber begrenzt.</li>
<li>Die Ursache für Instabilitäten liegt vermutlich in einer Speicherüberlastung, bedingt durch die maximale Aufnahmezeit in Kombination mit zahlreichen geladenen Bibliotheken und Plot-Ausgaben, die gemeinsam den RAM überfüllen.</li>
<li>Eine empfohlene Aufnahmezeit von 30 Sekunden hat die Stabilität deutlich verbessert und auch die allgemeine Verarbeitungszeit des Notebooks reduziert.</li>
</ul>
</section>
</section>
<section id="stand-17.06.2025" class="level1">
<h1>Stand : 17.06.2025</h1>
<section id="echtzeitfiltrierung-2" class="level3">
<h3 class="anchored" data-anchor-id="echtzeitfiltrierung-2">Echtzeitfiltrierung 2</h3>
<section id="analyse-zur-anbindung-des-i2s-rxtx" class="level4">
<h4 class="anchored" data-anchor-id="analyse-zur-anbindung-des-i2s-rxtx">Analyse zur Anbindung des I2S RX/TX</h4>
<p>Es ist gelungen, die LogiCORE I2S Transmitter (TX) und Receiver (RX) IPs gemäß dem <a href="https://docs.amd.com/r/en-US/pg308-i2s">Product Guide PG308</a> korrekt in den I2S-Audiostream des Audio-Codecs einzubinden.<br> Entgegen der offiziellen Dokumentation, die den Slave-Modus nicht unterstützt, konnten sowohl RX als auch TX im Slave-Modus betrieben werden, indem innerhalb von Vivado entsprechende Block-Property-Einstellungen vorgenommen wurden. Der Audio-Codec-Controller agiert dabei als Master für <em>bclk</em> und <em>lrclk</em>.<br> Die Initialisierung der RX/TX-IPs erfolgte aus einem Jupyter Notebook, indem spezifische Registeradressen gemäß dem Datenblatt gesetzt wurden. Der RX erhielt dabei Samplerate und Enable, beim TX reichte das Setzen des Enable-Registers.<br></p>
</section>
<section id="funktionstest-filtereinbindung" class="level4">
<h4 class="anchored" data-anchor-id="funktionstest-filtereinbindung">Funktionstest &amp; Filtereinbindung</h4>
<p>Zunächst wurde eine direkte Verbindung zwischen RX und TX über AXI-Stream hergestellt, was zu korrekter Audioausgabe führte, unabhängig davon, ob RX/TX vor oder nach dem Codec-Controller eingebunden wurden.<br> Als nächstes wurde der eigene Biquad-Filter-IP zwischen RX und TX eingefügt. Ab diesem Punkt war die Audioausgabe zwar noch vorhanden, jedoch kaum hörbar und scheinbar ungefiltert. Die eigene Biquad-Filter-IP nutzt dabei den fertigen <a href="https://de.mathworks.com/help/dsphdl/ref/biquadfilter.html">Biquad Filter</a> aus DSP HDL Toolbox / Filtering in Matlab. <br> Um den Fehler einzugrenzen, wurde eine neue, vereinfachte IP mit HDL Coder in Simulink erstellt, ein reiner Bypass ohne jegliche Filterlogik. Dennoch blieb die Ausgabe gleich leise. Dies deutet darauf hin, dass der Filter selbst nicht Ursache des Problems ist.</p>
</section>
<section id="weitere-tests" class="level4">
<h4 class="anchored" data-anchor-id="weitere-tests">Weitere Tests</h4>
<ul>
<li>Verschiedene Datenformate wurden getestet: int32, uint32, ufix inkl. Shifts und Gains – ohne nennenswerte Wirkung.</li>
<li>Ein Gain-Block in der IP änderte die Lautstärke nicht.</li>
<li>Ein <a href="https://docs.amd.com/r/en-US/pg085-axi4stream-infrastructure/AXI4-Stream-Data-FIFO?tocId=gyNUSa81sSudIrD3MNZ6aw">AXI4-Stream Data FIFO</a> zwischen RX und TX hingegen führte zu normaler Lautstärke – auch ohne Verarbeitung.</li>
<li>Eine eigene IP als Bypass und gleicher Puffergröße wie der FIFO führte nicht zum selben Ergebnis: Der Fehler liegt nicht nur an der Puffergröße.</li>
</ul>
</section>
<section id="vermutete-ursache" class="level4">
<h4 class="anchored" data-anchor-id="vermutete-ursache">Vermutete Ursache</h4>
<ul>
<li>Die durch HDL Coder erzeugte AXI-Stream-Implementierung scheint in ihrer minimalen Version <em>(TVALID, TDATA, generiertes TREADY)</em> nicht alle Timing- oder Handshakebedingungen zu erfüllen, wie sie vom TX erwartet werden.</li>
<li>Das optionale Signal TID[2:0], das bei RX und TX zur Unterscheidung der Kanäle dient, wird von der eigenen IP nicht verarbeitet. Auch das externe Durchreichen von TID brachte keine Verbesserung.</li>
<li>Da die Filter-IP in Kombination mit AXI-DMA korrekt funktioniert, liegt das Problem wahrscheinlich in der AXI-Kommunikation, nicht im Filter selbst.</li>
</ul>
</section>
<section id="fazit-der-echtzeitfiltrierung" class="level4">
<h4 class="anchored" data-anchor-id="fazit-der-echtzeitfiltrierung">Fazit der Echtzeitfiltrierung</h4>
<p>Die Umsetzung der Audio-Echtzeitverarbeitung , zeigte deutliche Einschränkungen. Zwar funktionierten der I2S Receiver und Transmitter einwandfrei in einer Direktverbindung, doch beim Einschleifen der eigenen IP kam es unabhängig von Datentyp oder Filterlogik zu einem stark gedämpften Ausgangssignal. Auch bei Verwendung eines einfachen Bypasses ohne jegliche Verarbeitung blieb das Signal zu leise, ein Hinweis darauf, dass nicht die Filterimplementierung, sondern die AXI-Stream-Schnittstelle der IP selbst das Problem darstellt.<br> Um das Verhalten korrekt umzusetzen, wäre eine vollwertige, AXI-konforme Implementierung nötig, inklusive Pufferung, Signalweiterleitung und detaillierter Kontrolle über die Handshake-Logik. <br> Die Erstellung einer solchen IP erfordert jedoch fortgeschrittene Kenntnisse im AXI-Protokoll sowie zusätzliche manuelle Anpassungen, die über die Möglichkeiten der automatisierten HDL-Generierung hinausgehen.<br> Da der Schwerpunkt auf der Implementierung des Filters liegt und nicht auf der Low-Level-AXI-Implementierung, wurde entschieden, für weitere Tests und Anwendungen den bewährten Weg über AXI DMA zu nutzen.</p>
</section>
</section>
<section id="noch-offene-punkte" class="level2">
<h2 class="anchored" data-anchor-id="noch-offene-punkte">Noch offene Punkte:</h2>
<ul>
<li>❌ Finales Design mit Audiofilterung und Einlesen digitaler Audiodateien (.wav)</li>
<li>❌ Dokumentation zu: DSP, IIR-Filter, Biquad-Strukturen, Matlab HDL-Coder + Simulink, Vivado, IP-Cores, (I2C), Pynq und Pynq-Z2 Board</li>
<li>❌ Umrechnung der Samplerate für externe <em>.wav</em>-Datein (44.1 -&gt; 48kHz)</li>
<li>❌ Schematische Beschreibung der Funktionsweise der Filter IP anhand eines Beispieles</li>
</ul>
</section>
<section id="bereits-erledigt" class="level2">
<h2 class="anchored" data-anchor-id="bereits-erledigt">Bereits erledigt:</h2>
<ul>
<li>✅/❌ Design eines digitalen IIR-Biquad-Filters mit Fixpunktkonvertierung der Koeffi- zienten für den FPGA.</li>
<li>✅ Erstellung und Einbindung des Filters als AXI-fähiger IP-Block in Vivado 2022.1</li>
<li>✅ Erstes Design mit Zynq-Processing-System und DMA-Block (Direct Memory Access) für das erste Filtern simulierter Werte.</li>
<li>✅✅/❌ JupiterNotebooks für Demonstration</li>
<li>✅✅/❌ Skript zur Steuerung des Filters auf PYNQ.</li>
<li>✅✅/❌❌ Realesierung der 4 Basisfilter (<em>HP, TP, BS, BP</em>)</li>
<li>✅ Erstes Design einer Lerndemonstration mit Visualisierung der Signalverarbeitung.</li>
<li>✅ Dokumentation zu: <strong>AXI</strong>, <strong>I2S,</strong>,</li>
</ul>
</section>
<section id="zusatz" class="level2">
<h2 class="anchored" data-anchor-id="zusatz">Zusatz:</h2>
<ul>
<li>❔Vergleich Filtertypen und Ordnung (Ellip, Butter, Chebyshev)</li>
<li>❔Design für die <strong>Echtzeit-Audiofilterung</strong> mit Audiocodec über I2S</li>
</ul>
</section>
</section>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopiert");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopiert");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>  </div> <!-- /content -->  <script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script> 
  
</body></html>